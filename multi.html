<!DOCTYPE html>
<html lang="en">
<head>
    <title>Snowman Multiverse: The Eternal Void (nice name)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; text-align: center; cursor: pointer; z-index: 10;
            padding: 20px; border: 2px solid #00d2ff; background: rgba(0,0,0,0.8);
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="overlay" onclick="startAudio()"> [ CLICK TO ENTER MULTIVERSE ] </div>
    <canvas id="mc"></canvas>

    <script>
const cvs = document.getElementById("mc");
const ctx = cvs.getContext("2d");

let universes = [];
let stars = [];
let explosions = [];
const MAX_UNIVERSES = 14; 
const STAR_COUNT = 7000;

// CROSS-BROWSER COORDINATE SYSTEM
let center = { x: 0, y: 0 };

function res() {
    // 1. Set internal "drawing buffer" (The HD resolution)
    cvs.width = 2400; 
    cvs.height = 2400;
    
    // 2. Set external "display size" (What you actually see)
    cvs.style.width = "100vw";
    cvs.style.height = "100vh";
    cvs.style.display = "block";

    // 3. Sync the center coordinates to the buffer size
    center.x = cvs.width / 2;
    center.y = cvs.height / 2;
}
res();

// --- BALANCED AUDIO ENGINE (CHROME & FIREFOX COMPATIBLE) ---
let audioCtx;
function startAudio() {
    document.getElementById('overlay').style.display = 'none';
    // Cross-browser AudioContext initialization
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Constant Heavy Black Hole Thrum
    const thrumOsc = audioCtx.createOscillator();
    const thrumGain = audioCtx.createGain();
    thrumOsc.type = 'triangle'; 
    thrumOsc.frequency.setValueAtTime(35, audioCtx.currentTime); 
    thrumGain.gain.setValueAtTime(0.25, audioCtx.currentTime); 
    thrumOsc.connect(thrumGain);
    thrumGain.connect(audioCtx.destination);
    thrumOsc.start();

    const vortexOsc = audioCtx.createOscillator();
    const vortexGain = audioCtx.createGain();
    vortexOsc.type = 'sine';
    vortexOsc.frequency.setValueAtTime(55, audioCtx.currentTime);
    vortexGain.gain.setValueAtTime(0.12, audioCtx.currentTime);
    vortexOsc.connect(vortexGain);
    vortexGain.connect(audioCtx.destination);
    vortexOsc.start();
}

function playImpact(freq, vol) {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const balancedVol = freq > 500 ? vol * 0.1 : vol * 1.8; 
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.4);
    gain.gain.setValueAtTime(balancedVol, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.4);
}

// --- STAR LOGIC (UPDATED WITH center.x/y) ---
function createStar(isStatic = false) {
    const angle = Math.random() * Math.PI * 2;
    const dist = isStatic ? Math.random() * 2000 : 1500 + Math.random() * 500;
    return {
        angle: angle, dist: dist,
        speed: 0.2 + Math.random() * 1.5, 
        size: Math.random() * 2 + 1,
        isSuckedIn: Math.random() > 0.3,
        color: Math.random() > 0.5 ? "#fff" : "#70d6ff"
    };
}
for(let i=0; i<STAR_COUNT; i++) stars.push(createStar(true));

function updateStars(t) {
    // 1. Draw Impact Explosions
    for (let i = explosions.length - 1; i >= 0; i--) {
        let e = explosions[i];
        ctx.fillStyle = `rgba(112, 214, 255, ${e.alpha})`;
        ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill();
        e.r += 2; e.alpha -= 0.04;
        if (e.alpha <= 0) explosions.splice(i, 1);
    }

    // 2. Draw and Distort Stars
    for (let i = stars.length - 1; i >= 0; i--) {
        let s = stars[i];
        
        // Basic Gravity Pull
        const gravity = s.isSuckedIn ? (40000 / (s.dist * s.dist)) : 0.1;
        s.dist -= (s.speed + gravity);

        // --- GRAVITY DISTORT START ---
        // This makes stars "swirl" faster as they reach the event horizon
        if (s.dist < 600) {
            s.angle += (600 - s.dist) * 0.00001; 
        }
        // -----------------------------
        
        s.angle += (gravity * 0.01);

        // Calculate visual position
        let sx = center.x + Math.cos(s.angle) * s.dist;
        let sy = center.y + Math.sin(s.angle) * s.dist;
        
        // Calculate stretch (Tail)
        const tailLength = s.dist < 500 ? 30 : 15; // Stretch more when close
        let sEndx = center.x + Math.cos(s.angle) * (s.dist + tailLength);
        let sEndy = center.y + Math.sin(s.angle) * (s.dist + tailLength);

        // Render the star streak
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.size;
        ctx.globalAlpha = Math.min(1, s.dist / 400);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sEndx, sEndy);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // If they hit the Event Horizon (radius ~200), explode
        if (s.dist < 195) {
            explosions.push({ x: sx, y: sy, r: 2, alpha: 1 });
            playImpact(800 + Math.random() * 400, 0.02);
            stars.splice(i, 1);
            stars.push(createStar(false)); 
        }
    }
}


// --- UNIVERSE & SNOWMAN LOGIC ---
function createUniverse() {
    return {
        id: Math.floor(Math.random() * 900) + 100,
        angle: Math.random() * Math.PI * 2,
        dist: 700 + Math.random() * 400,
        speed: 0.002 + Math.random() * 0.003,
        size: 160,
        hue: Math.random() * 360,
        opacity: 1,
        isDoomed: false, 
        lifeTimer: Math.random() < 0.2 ? 200 : 800 + Math.random() * 1200,
        age: 0
    };
}

function drawSnowman(ctx, x, y, s, alpha) {
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    [ {r:10, y:0}, {r:7, y:-12}, {r:5, y:-22} ].forEach(b => {
        ctx.beginPath(); ctx.arc(x, y + b.y*s, b.r*s, 0, Math.PI*2); ctx.fill();
    });
}

function drawUniverse(u, time) {
    const stretch = (u.isDoomed && u.dist < 550) ? 1 + (550 - u.dist) / 150 : 1;
    ctx.save();
    ctx.translate(center.x + Math.cos(u.angle) * u.dist, center.y + Math.sin(u.angle) * u.dist);
    ctx.scale(stretch, 1 / stretch);
    ctx.globalAlpha = u.opacity;
    const sz = u.size;
    ctx.strokeStyle = u.isDoomed ? `red` : `hsl(${u.hue}, 100%, 70%)`;
    ctx.lineWidth = 4;
    ctx.strokeRect(-sz/2, -sz/2, sz, sz);
    ctx.fillStyle = "black";
    ctx.fillRect(-sz/2, -sz/2, sz, sz);
    ctx.fillStyle = u.isDoomed ? "#ff4e50" : `hsl(${u.hue}, 100%, 90%)`;
    ctx.beginPath(); ctx.arc(0, 0, sz/10, 0, Math.PI*2); ctx.fill();
    for(let i=1; i <= 3; i++) {
        const ang = time * (1.5/i) + u.id;
        const px = Math.cos(ang) * ((sz/2.5) * (i/3));
        const py = Math.sin(ang) * ((sz/2.5) * (i/3));
        ctx.fillStyle = `hsl(${(u.hue + i*40)%360}, 60%, 60%)`;
        ctx.beginPath(); ctx.arc(px, py, sz/18, 0, Math.PI*2); ctx.fill();
        drawSnowman(ctx, px, py - sz/18, sz/280, u.opacity);
    }
    ctx.fillStyle = "white";
    ctx.font = "bold 18px 'Courier New'";
    ctx.fillText(`${u.isDoomed ? "⚠ DECAYING" : "✓ STABLE"} [U-${u.id}]`, -sz/2, -sz/2 - 12);
    ctx.restore();
}

function drawBlackHole(time) {
    const r = 210; // The Event Horizon radius
    ctx.save();
    ctx.translate(center.x, center.y);

    // 1. GRAVITATIONAL LENSING (The Warped Arches)
    // This draws the light bent by gravity from the back of the disk
    ctx.strokeStyle = "rgba(0, 229, 255, 0.25)";
    ctx.lineWidth = 25;
    
    // Top Arch
    ctx.beginPath();
    ctx.ellipse(0, -15, r * 2.8, r * 1.6, 0, Math.PI, 0); 
    ctx.stroke();
    
    // Bottom Arch
    ctx.beginPath();
    ctx.ellipse(0, 15, r * 2.8, r * 1.6, 0, 0, Math.PI); 
    ctx.stroke();

    // 2. ACCRETION DISK (The Horizontal Glowing Plasma)
    ctx.save();
    ctx.rotate(time * 0.2); // Slowly rotate the plasma
    
    // Use an offset (-80) to make the left side brighter (Doppler Boosting)
    const diskGrad = ctx.createRadialGradient(-80, 0, r, 0, 0, r * 4);
    diskGrad.addColorStop(0, "#ffffff"); // Pure heat
    diskGrad.addColorStop(0.1, "#00e5ff"); // Blue shift
    diskGrad.addColorStop(0.4, "rgba(0, 100, 255, 0.3)");
    diskGrad.addColorStop(1, "transparent");
    
    ctx.scale(3.2, 0.45); // Flatten the disk for perspective
    ctx.fillStyle = diskGrad;
    
    // Add a shimmering "heat" effect
    const shimmer = Math.sin(time * 4) * 10;
    ctx.beginPath(); 
    ctx.arc(0, 0, r * 4 + shimmer, 0, Math.PI * 2); 
    ctx.fill();
    ctx.restore();

    // 3. PHOTON SPHERE (The sharp white rim)
    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
    ctx.lineWidth = 4;
    ctx.shadowBlur = 30;
    ctx.shadowColor = "#00e5ff";
    ctx.beginPath(); 
    ctx.arc(0, 0, r + 6, 0, Math.PI * 2); 
    ctx.stroke();
    ctx.shadowBlur = 0; // Reset blur for performance

        // --- ADD THIS DISTORTION LAYER (Place before Event Horizon) ---
    const lensR = r * 2.5; 
    const lensing = ctx.createRadialGradient(0, 0, r, 0, 0, lensR);
    lensing.addColorStop(0, "rgba(255, 255, 255, 0.9)"); 
    lensing.addColorStop(0.1, "rgba(100, 220, 255, 0.4)"); 
    lensing.addColorStop(1, "transparent");

    ctx.save();
    ctx.scale(1.2, 0.8); 
    ctx.fillStyle = lensing;
    ctx.beginPath(); ctx.arc(0, 0, lensR, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    // --------------------------------------------------------------

    // THE EVENT HORIZON (This should already be in your code)
    ctx.fillStyle = "black";
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();

    // 4. THE EVENT HORIZON (The Shadow)
    ctx.fillStyle = "black";
    ctx.beginPath(); 
    ctx.arc(0, 0, r, 0, Math.PI * 2); 
    ctx.fill();

    // 5. POLAR JETS (Vertical Energy Beams)
    const jetGrad = ctx.createLinearGradient(0, -1000, 0, 1000);
    jetGrad.addColorStop(0, "transparent");
    jetGrad.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
    jetGrad.addColorStop(1, "transparent");
    ctx.fillStyle = jetGrad;
    ctx.fillRect(-10, -1100, 30, 2200);

    ctx.restore();
}

// MAIN ANIMATION LOOP
function loop() {
    const t = Date.now() * 0.001;
    ctx.fillStyle = "#010103";
    ctx.fillRect(0, 0, cvs.width, cvs.height);
    
    updateStars(t);
    drawBlackHole(t);
    
    if (universes.length < MAX_UNIVERSES) universes.push(createUniverse());
    
    for (let i = universes.length - 1; i >= 0; i--) {
        let u = universes[i];
        u.angle += u.speed; u.age++;
        if (!u.isDoomed && u.age > u.lifeTimer) u.isDoomed = true;
        if (u.isDoomed) { u.dist -= 2.5; if (u.dist < 450) u.opacity -= 0.01; }
        else { u.dist += Math.sin(t + u.id) * 0.5; }
        if (u.dist < 180 || u.opacity <= 0) { 
            playImpact(150, 0.1); universes.splice(i, 1); continue; 
        }
        drawUniverse(u, t);
    }
    requestAnimationFrame(loop);
}

// Firefox fix: Use standard addEventListener
window.addEventListener('resize', res);
loop();
</script>

</body>
</html>
