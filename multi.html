<!DOCTYPE html>
<html lang="en">
<head>
    <title>Snowman Multiverse: The Eternal Void</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; text-align: center; cursor: pointer; z-index: 10;
            padding: 20px; border: 2px solid #00d2ff; background: rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="overlay" onclick="startAudio()"> [ CLICK TO ENTER MULTIVERSE ] </div>
    <canvas id="mc"></canvas>

    <script>
const cvs = document.getElementById("mc");
const ctx = cvs.getContext("2d");

let universes = [];
let stars = [];
let explosions = [];
const MAX_UNIVERSES = 6; 
const STAR_COUNT = 250;

// --- BALANCED AUDIO ENGINE ---
let audioCtx;
function startAudio() {
    document.getElementById('overlay').style.display = 'none';
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // 1. Constant Heavy Black Hole Thrum
    const thrumOsc = audioCtx.createOscillator();
    const thrumGain = audioCtx.createGain();
    thrumOsc.type = 'triangle'; 
    thrumOsc.frequency.setValueAtTime(35, audioCtx.currentTime); 
    thrumGain.gain.setValueAtTime(0.25, audioCtx.currentTime); // Louder thrum
    thrumOsc.connect(thrumGain);
    thrumGain.connect(audioCtx.destination);
    thrumOsc.start();

    // 2. Secondary Vortex Layer
    const vortexOsc = audioCtx.createOscillator();
    const vortexGain = audioCtx.createGain();
    vortexOsc.type = 'sine';
    vortexOsc.frequency.setValueAtTime(55, audioCtx.currentTime);
    vortexGain.gain.setValueAtTime(0.12, audioCtx.currentTime);
    vortexOsc.connect(vortexGain);
    vortexGain.connect(audioCtx.destination);
    vortexOsc.start();
}

function playImpact(freq, vol) {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    // Star volume is nerfed; Universe volume is boosted
    const balancedVol = freq > 500 ? vol * 0.1 : vol * 1.8; 
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.4);
    gain.gain.setValueAtTime(balancedVol, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.4);
}

function res() {
    cvs.width = window.innerWidth * 2;
    cvs.height = window.innerHeight * 2;
    cvs.style.width = "100vw";
    cvs.style.height = "100vh";
}
res();

const CX = cvs.width / 2;
const CY = cvs.height / 2;

// --- STAR LOGIC ---
function createStar(isStatic = false) {
    const angle = Math.random() * Math.PI * 2;
    const maxDist = Math.min(CX, CY) * 1.5;
    const dist = isStatic ? Math.random() * maxDist : maxDist;
    return {
        angle: angle,
        dist: dist,
        speed: 0.2 + Math.random() * 1.5, 
        size: Math.random() * 2 + 1,
        isSuckedIn: Math.random() > 0.3,
        color: Math.random() > 0.5 ? "#fff" : "#70d6ff"
    };
}
for(let i=0; i<STAR_COUNT; i++) stars.push(createStar(true));

function updateStars(t) {
    for (let i = explosions.length - 1; i >= 0; i--) {
        let e = explosions[i];
        ctx.fillStyle = `rgba(112, 214, 255, ${e.alpha})`;
        ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill();
        e.r += 2; e.alpha -= 0.04;
        if (e.alpha <= 0) explosions.splice(i, 1);
    }
    for (let i = stars.length - 1; i >= 0; i--) {
        let s = stars[i];
        const gravity = s.isSuckedIn ? (40000 / (s.dist * s.dist)) : 0.1;
        s.dist -= (s.speed + gravity);
        s.angle += (gravity * 0.01);
        let sx = CX + Math.cos(s.angle) * s.dist;
        let sy = CY + Math.sin(s.angle) * s.dist;
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.size;
        ctx.globalAlpha = Math.min(1, s.dist / 400);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(CX + Math.cos(s.angle) * (s.dist + 15), CY + Math.sin(s.angle) * (s.dist + 15));
        ctx.stroke();
        ctx.globalAlpha = 1;
        if (s.dist < 195) {
            explosions.push({ x: sx, y: sy, r: 2, alpha: 1 });
            playImpact(800 + Math.random() * 400, 0.02);
            stars.splice(i, 1);
            stars.push(createStar(false)); 
        }
    }
}

// --- UNIVERSE LOGIC ---
function createUniverse() {
    const screenLimit = Math.min(CX, CY) * 0.9;
    // VARIATION: Some die in 200 frames, some live for 2000
    const lifeTimer = Math.random() < 0.2 ? 200 : 800 + Math.random() * 1200; 
    return {
        id: Math.floor(Math.random() * 900) + 100,
        angle: Math.random() * Math.PI * 2,
        dist: 500 + Math.random() * (screenLimit - 500),
        speed: 0.002 + Math.random() * 0.003,
        size: 140 + Math.random() * 40,
        hue: Math.random() * 360,
        opacity: 1,
        isDoomed: false, 
        lifeTimer: lifeTimer,
        age: 0
    };
}

function drawSnowman(ctx, x, y, s, alpha) {
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    [ {r:10, y:0}, {r:7, y:-12}, {r:5, y:-22} ].forEach(b => {
        ctx.beginPath(); ctx.arc(x, y + b.y*s, b.r*s, 0, Math.PI*2); ctx.fill();
    });
}

function drawUniverse(u, time) {
    const stretch = (u.isDoomed && u.dist < 550) ? 1 + (550 - u.dist) / 150 : 1;
    ctx.save();
    ctx.translate(CX + Math.cos(u.angle) * u.dist, CY + Math.sin(u.angle) * u.dist);
    ctx.scale(stretch, 1 / stretch);
    ctx.globalAlpha = u.opacity;
    const sz = u.size;
    ctx.strokeStyle = u.isDoomed ? `red` : `hsl(${u.hue}, 100%, 70%)`;
    ctx.lineWidth = 4;
    ctx.strokeRect(-sz/2, -sz/2, sz, sz);
    ctx.fillStyle = "black";
    ctx.fillRect(-sz/2, -sz/2, sz, sz);
    ctx.fillStyle = u.isDoomed ? "#ff4e50" : `hsl(${u.hue}, 100%, 90%)`;
    ctx.beginPath(); ctx.arc(0, 0, sz/10, 0, Math.PI*2); ctx.fill();
    for(let i=1; i <= 3; i++) {
        const ang = time * (1.5/i) + u.id;
        const px = Math.cos(ang) * ((sz/2.5) * (i/3));
        const py = Math.sin(ang) * ((sz/2.5) * (i/3));
        ctx.fillStyle = `hsl(${(u.hue + i*40)%360}, 60%, 60%)`;
        ctx.beginPath(); ctx.arc(px, py, sz/18, 0, Math.PI*2); ctx.fill();
        drawSnowman(ctx, px, py - sz/18, sz/280, u.opacity);
    }
    ctx.fillStyle = "white";
    ctx.font = "bold 18px 'Courier New'";
    ctx.fillText(`${u.isDoomed ? "⚠ DECAYING" : "✓ STABLE"} [U-${u.id}]`, -sz/2, -sz/2 - 12);
    ctx.restore();
}

function drawBlackHole(time) {
    const r = 210; // Event Horizon Radius
    ctx.save();
    ctx.translate(CX, CY);

    // 1. DISTANT GRAVITATIONAL LENSING (The Far Halo)
    // This represents light from behind the black hole bent over the top
    ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
    ctx.lineWidth = 15;
    ctx.beginPath();
    ctx.ellipse(0, 0, r * 2.8, r * 1.2, 0, 0, Math.PI * 2);
    ctx.stroke();

    // 2. RELATIVISTIC JETS (The Polar Beams)
    const jetGrad = ctx.createLinearGradient(0, -1000, 0, 1000);
    jetGrad.addColorStop(0, "transparent");
    jetGrad.addColorStop(0.5, "rgba(100, 220, 255, 0.7)");
    jetGrad.addColorStop(1, "transparent");
    ctx.fillStyle = jetGrad;
    ctx.fillRect(-8, -1200, 16, 2400);

    // 3. PHOTON SPHERE (The Main Accretion Ring)
    // We add a subtle "wobble" using Math.sin for realistic heat shimmer
    ctx.save();
    ctx.rotate(time * 0.3);
    const disk = ctx.createRadialGradient(-70, 0, r, 0, 0, r * 3.5);
    disk.addColorStop(0, "#ffffff"); // Hottest inner edge
    disk.addColorStop(0.1, "#00e5ff"); // Relativistic blue-shift
    disk.addColorStop(0.4, "rgba(0, 100, 255, 0.3)");
    disk.addColorStop(1, "transparent");
    
    ctx.scale(2.8, 0.45); 
    ctx.fillStyle = disk;
    ctx.beginPath();
    ctx.arc(0, 0, r * 3.5 + Math.sin(time*2)*5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // 4. THE SHADOW (Event Horizon)
    // Pure black void with a soft lensing glow at the very edge
    const edgeGlow = ctx.createRadialGradient(0, 0, r - 5, 0, 0, r + 5);
    edgeGlow.addColorStop(0, "black");
    edgeGlow.addColorStop(1, "rgba(255, 255, 255, 0.6)");
    ctx.fillStyle = edgeGlow;
    ctx.beginPath();
    ctx.arc(0, 0, r + 5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}

function loop() {
    const t = Date.now() * 0.001;
    ctx.fillStyle = "#010103";
    ctx.fillRect(0, 0, cvs.width, cvs.height);
    updateStars(t);
    drawBlackHole(t);
    if (universes.length < MAX_UNIVERSES) universes.push(createUniverse());
    for (let i = universes.length - 1; i >= 0; i--) {
        let u = universes[i];
        u.angle += u.speed;
        u.age++;
        if (!u.isDoomed && u.age > u.lifeTimer) u.isDoomed = true;
        if (u.isDoomed) {
            u.dist -= 2.5; 
            if (u.dist < 450) u.opacity -= 0.01;
        } else {
            const maxVisible = Math.min(CX, CY) * 0.9;
            if(u.dist > maxVisible) u.dist = maxVisible;
            u.dist += Math.sin(t + u.id) * 0.5;
        }
        if (u.dist < 180 || u.opacity <= 0) { 
            playImpact(150, 0.1); 
            universes.splice(i, 1); 
            continue; 
        }
        drawUniverse(u, t);
    }
    requestAnimationFrame(loop);
}
window.onresize = res;
loop();
    </script>
</body>
</html>
