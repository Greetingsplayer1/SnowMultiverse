<!DOCTYPE html>
<html lang="en">
<head>
    <title>Snowman Multiverse: The Eternal Void</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; text-align: center; cursor: pointer; z-index: 10;
            padding: 20px; border: 2px solid #00d2ff; background: rgba(0,0,0,0.8);
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="overlay" onclick="startAudio()"> [ CLICK TO ENTER MULTIVERSE ] </div>
    <canvas id="mc"></canvas>

    <script>
const cvs = document.getElementById("mc");
const ctx = cvs.getContext("2d");

let universes = [];
let stars = [];
let explosions = [];
const MAX_UNIVERSES = 6; 
const STAR_COUNT = 250;

// CROSS-BROWSER COORDINATE SYSTEM
let center = { x: 0, y: 0 };

function res() {
    // 1. Set internal "drawing buffer" (The HD resolution)
    cvs.width = 2400; 
    cvs.height = 2400;
    
    // 2. Set external "display size" (What you actually see)
    cvs.style.width = "100vw";
    cvs.style.height = "100vh";
    cvs.style.display = "block";

    // 3. Sync the center coordinates to the buffer size
    center.x = cvs.width / 2;
    center.y = cvs.height / 2;
}
res();

// --- BALANCED AUDIO ENGINE (CHROME & FIREFOX COMPATIBLE) ---
let audioCtx;
function startAudio() {
    document.getElementById('overlay').style.display = 'none';
    // Cross-browser AudioContext initialization
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Constant Heavy Black Hole Thrum
    const thrumOsc = audioCtx.createOscillator();
    const thrumGain = audioCtx.createGain();
    thrumOsc.type = 'triangle'; 
    thrumOsc.frequency.setValueAtTime(35, audioCtx.currentTime); 
    thrumGain.gain.setValueAtTime(0.25, audioCtx.currentTime); 
    thrumOsc.connect(thrumGain);
    thrumGain.connect(audioCtx.destination);
    thrumOsc.start();

    const vortexOsc = audioCtx.createOscillator();
    const vortexGain = audioCtx.createGain();
    vortexOsc.type = 'sine';
    vortexOsc.frequency.setValueAtTime(55, audioCtx.currentTime);
    vortexGain.gain.setValueAtTime(0.12, audioCtx.currentTime);
    vortexOsc.connect(vortexGain);
    vortexGain.connect(audioCtx.destination);
    vortexOsc.start();
}

function playImpact(freq, vol) {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const balancedVol = freq > 500 ? vol * 0.1 : vol * 1.8; 
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.4);
    gain.gain.setValueAtTime(balancedVol, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.4);
}

// --- STAR LOGIC (UPDATED WITH center.x/y) ---
function createStar(isStatic = false) {
    const angle = Math.random() * Math.PI * 2;
    const dist = isStatic ? Math.random() * 2000 : 1500 + Math.random() * 500;
    return {
        angle: angle, dist: dist,
        speed: 0.2 + Math.random() * 1.5, 
        size: Math.random() * 2 + 1,
        isSuckedIn: Math.random() > 0.3,
        color: Math.random() > 0.5 ? "#fff" : "#70d6ff"
    };
}
for(let i=0; i<STAR_COUNT; i++) stars.push(createStar(true));

function updateStars(t) {
    for (let i = explosions.length - 1; i >= 0; i--) {
        let e = explosions[i];
        ctx.fillStyle = `rgba(112, 214, 255, ${e.alpha})`;
        ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill();
        e.r += 2; e.alpha -= 0.04;
        if (e.alpha <= 0) explosions.splice(i, 1);
    }
    for (let i = stars.length - 1; i >= 0; i--) {
        let s = stars[i];
        const gravity = s.isSuckedIn ? (40000 / (s.dist * s.dist)) : 0.1;
        s.dist -= (s.speed + gravity);
        s.angle += (gravity * 0.01);
        let sx = center.x + Math.cos(s.angle) * s.dist;
        let sy = center.y + Math.sin(s.angle) * s.dist;
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.size;
        ctx.globalAlpha = Math.min(1, s.dist / 400);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(center.x + Math.cos(s.angle) * (s.dist + 15), center.y + Math.sin(s.angle) * (s.dist + 15));
        ctx.stroke();
        ctx.globalAlpha = 1;
        if (s.dist < 195) {
            explosions.push({ x: sx, y: sy, r: 2, alpha: 1 });
            playImpact(800 + Math.random() * 400, 0.02);
            stars.splice(i, 1);
            stars.push(createStar(false)); 
        }
    }
}

// --- UNIVERSE & SNOWMAN LOGIC ---
function createUniverse() {
    return {
        id: Math.floor(Math.random() * 900) + 100,
        angle: Math.random() * Math.PI * 2,
        dist: 700 + Math.random() * 400,
        speed: 0.002 + Math.random() * 0.003,
        size: 160,
        hue: Math.random() * 360,
        opacity: 1,
        isDoomed: false, 
        lifeTimer: Math.random() < 0.2 ? 200 : 800 + Math.random() * 1200,
        age: 0
    };
}

function drawSnowman(ctx, x, y, s, alpha) {
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    [ {r:10, y:0}, {r:7, y:-12}, {r:5, y:-22} ].forEach(b => {
        ctx.beginPath(); ctx.arc(x, y + b.y*s, b.r*s, 0, Math.PI*2); ctx.fill();
    });
}

function drawUniverse(u, time) {
    const stretch = (u.isDoomed && u.dist < 550) ? 1 + (550 - u.dist) / 150 : 1;
    ctx.save();
    ctx.translate(center.x + Math.cos(u.angle) * u.dist, center.y + Math.sin(u.angle) * u.dist);
    ctx.scale(stretch, 1 / stretch);
    ctx.globalAlpha = u.opacity;
    const sz = u.size;
    ctx.strokeStyle = u.isDoomed ? `red` : `hsl(${u.hue}, 100%, 70%)`;
    ctx.lineWidth = 4;
    ctx.strokeRect(-sz/2, -sz/2, sz, sz);
    ctx.fillStyle = "black";
    ctx.fillRect(-sz/2, -sz/2, sz, sz);
    ctx.fillStyle = u.isDoomed ? "#ff4e50" : `hsl(${u.hue}, 100%, 90%)`;
    ctx.beginPath(); ctx.arc(0, 0, sz/10, 0, Math.PI*2); ctx.fill();
    for(let i=1; i <= 3; i++) {
        const ang = time * (1.5/i) + u.id;
        const px = Math.cos(ang) * ((sz/2.5) * (i/3));
        const py = Math.sin(ang) * ((sz/2.5) * (i/3));
        ctx.fillStyle = `hsl(${(u.hue + i*40)%360}, 60%, 60%)`;
        ctx.beginPath(); ctx.arc(px, py, sz/18, 0, Math.PI*2); ctx.fill();
        drawSnowman(ctx, px, py - sz/18, sz/280, u.opacity);
    }
    ctx.fillStyle = "white";
    ctx.font = "bold 18px 'Courier New'";
    ctx.fillText(`${u.isDoomed ? "⚠ DECAYING" : "✓ STABLE"} [U-${u.id}]`, -sz/2, -sz/2 - 12);
    ctx.restore();
}

function drawBlackHole(time) {
    const r = 210;
    ctx.save();
    ctx.translate(center.x, center.y);
    
    // Polar Beams
    const jetGrad = ctx.createLinearGradient(0, -1000, 0, 1000);
    jetGrad.addColorStop(0.5, "rgba(100, 220, 255, 0.7)");
    ctx.fillStyle = jetGrad; ctx.fillRect(-8, -1200, 16, 2400);

    // Accretion Disk (Gargantua Style)
    ctx.save();
    ctx.rotate(time * 0.3);
    const disk = ctx.createRadialGradient(-70, 0, r, 0, 0, r * 3.5);
    disk.addColorStop(0, "#ffffff"); disk.addColorStop(0.1, "#00e5ff"); disk.addColorStop(1, "transparent");
    ctx.scale(2.8, 0.45); ctx.fillStyle = disk;
    ctx.beginPath(); ctx.arc(0, 0, r * 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    
    ctx.fillStyle = "black";
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
}

// MAIN ANIMATION LOOP
function loop() {
    const t = Date.now() * 0.001;
    ctx.fillStyle = "#010103";
    ctx.fillRect(0, 0, cvs.width, cvs.height);
    
    updateStars(t);
    drawBlackHole(t);
    
    if (universes.length < MAX_UNIVERSES) universes.push(createUniverse());
    
    for (let i = universes.length - 1; i >= 0; i--) {
        let u = universes[i];
        u.angle += u.speed; u.age++;
        if (!u.isDoomed && u.age > u.lifeTimer) u.isDoomed = true;
        if (u.isDoomed) { u.dist -= 2.5; if (u.dist < 450) u.opacity -= 0.01; }
        else { u.dist += Math.sin(t + u.id) * 0.5; }
        if (u.dist < 180 || u.opacity <= 0) { 
            playImpact(150, 0.1); universes.splice(i, 1); continue; 
        }
        drawUniverse(u, t);
    }
    requestAnimationFrame(loop);
}

// Firefox fix: Use standard addEventListener
window.addEventListener('resize', res);
loop();
</script>

</body>
</html>
